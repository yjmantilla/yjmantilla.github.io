<script>

function do_graph(path){
    fetch(path).then(res => res.json()).then(data => {
      
      nodes_ = data.nodes.map(t => t.id);
      data.links.forEach(link => {
        const a = data.nodes[nodes_.indexOf(link.source)];
        const b = data.nodes[nodes_.indexOf(link.target)];
        !a.neighbors && (a.neighbors = []);
        !b.neighbors && (b.neighbors = []);
        a.neighbors.push(b);
        b.neighbors.push(a);

        !a.links && (a.links = []);
        !b.links && (b.links = []);
        a.links.push(link);
        b.links.push(link);
      });
      const NODE_R = 8;
      const highlightNodes = new Set();
      const highlightLinks = new Set();
      let hoverNode = null;
      
      const elem = document.getElementById('graph');
      const Graph = ForceGraph()(elem)
        .graphData(data)
        //.nodeRelSize(NODE_R)
        .onNodeHover(node => {
          highlightNodes.clear();
          highlightLinks.clear();
          if (node) {
            highlightNodes.add(node);
            if (typeof node.neighbors !== 'undefined'){
            node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
            node.links.forEach(link => highlightLinks.add(link));
            }
          }
          hoverNode = node || null;
          elem.style.cursor = node ? '-webkit-grab' : null;
        })
        .onLinkHover(link => {
          highlightNodes.clear();
          highlightLinks.clear();

          if (link) {
            highlightLinks.add(link);
            highlightNodes.add(link.source);
            highlightNodes.add(link.target);
          }
        })
        .autoPauseRedraw(false) // keep redrawing after engine has stopped
        .backgroundColor('#000000')
        .nodeId('id')
        .linkColor(() => 'rgba(0,255,0,0.2)')
        //.linkDirectionalParticles(1)
        .linkWidth(link => highlightLinks.has(link) ? 5 : 1)
        .linkDirectionalParticles(4)
        .linkDirectionalParticleWidth(link => highlightLinks.has(link) ? 4 : 0)
        .onNodeClick(node => window.open(node.url, '_blank'))
        .nodePointerAreaPaint((node, color, ctx) => {
          ctx.fillStyle = color;
          const bckgDimensions = node.__bckgDimensions;
          bckgDimensions && ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);
        })
        //.nodeCanvasObjectMode(node => highlightNodes.has(node) ? 'before' : undefined)
        .nodeCanvasObject((node, ctx, globalScale) => {
          const label = node.id;
          const fontSize = 12/globalScale;
          ctx.font = `${fontSize}px Sans-Serif`;
          const textWidth = ctx.measureText(label).width;
          const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2); // some padding

          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          // ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);
          //
          // ctx.beginPath();
          // ctx.arc(node.x, node.y, NODE_R * 1.4, 0, 2 * Math.PI, false);
          // ctx.fillStyle = node === hoverNode ? 'red' : 'orange';
          // ctx.fill();
          //
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = node.color;
          ctx.fillText(label, node.x, node.y);

          node.__bckgDimensions = bckgDimensions; // to re-use in nodePointerAreaPaint
        })
        //.onNodeHover(node => elem.style.cursor = node ? 'pointer' : null)
    });
  }
</script>

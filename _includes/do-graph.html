<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<div id="tooltip2" style="display: none; position: absolute; padding: 10px; background-color: white; border: 1px solid black; border-radius: 5px;"></div>
<div id="tooltip" style="display: none; position: absolute; z-index: 1000; left: 50px; top: 50px; padding: 10px; background-color: white; border: 1px solid black; border-radius: 5px; opacity: 0.5;"></div>

<script>
let mousePosition = { x: 0, y: 0 };

document.addEventListener('mousemove', (event) => {
  mousePosition.x = event.clientX;
  mousePosition.y = event.clientY;
});

function do_graph(path){

  fetch(path).then(res => res.json()).then(data => {
      
      nodes_ = data.nodes.map(t => t.id);
      data.links.forEach(link => {
        const a = data.nodes[nodes_.indexOf(link.source)];
        const b = data.nodes[nodes_.indexOf(link.target)];
        !a.neighbors && (a.neighbors = []);
        !b.neighbors && (b.neighbors = []);
        a.neighbors.push(b);
        b.neighbors.push(a);

        !a.links && (a.links = []);
        !b.links && (b.links = []);
        a.links.push(link);
        b.links.push(link);
      });
      const NODE_R = 8;
      const highlightNodes = new Set();
      const highlightLinks = new Set();
      let hoverNode = null;
      

      // dat.gui setup
      const gui = new dat.GUI();
      const settings = {enableTooltip: false};
      const uniqueCategories = new Set();
      gui.add(settings, 'enableTooltip').name('Enable Preview');
      const categoriesFolder = gui.addFolder('Categories');

        // Collect unique categories
        data.nodes.forEach(node => {
            uniqueCategories.add(node.category);
        });

        // Initialize settings object
        uniqueCategories.forEach(category => {
            settings[category] = true; // default all categories to true
        });


      // Toggle All function
        function toggleAll(value) {
            uniqueCategories.forEach(category => {
                settings[category] = value;
            });
            updateGraph();
            gui.updateDisplay(); // Update GUI display
        }

        // Add Toggle All and Detoggle All buttons
        categoriesFolder.add({ toggleAll: () => toggleAll(true) }, 'toggleAll').name("Toggle All");
        categoriesFolder.add({ toggleAll: () => toggleAll(false) }, 'toggleAll').name("Detoggle All");

          // Add category controls to GUI
          uniqueCategories.forEach(category => {
          categoriesFolder.add(settings, category).onChange(updateGraph);
      });

        // Update function for filtering
        function updateGraph() {
            const filteredNodes = data.nodes.filter(node => 
                settings[node.category]
            );
            const filteredLinks = data.links.filter(link => 
                filteredNodes.includes(link.source) && filteredNodes.includes(link.target)
            );

            Graph.graphData({ nodes: filteredNodes, links: filteredLinks });
        }

      const elem = document.getElementById('graph');
      const Graph = ForceGraph()(elem)
        .graphData(data)
        //.nodeRelSize(NODE_R)
        .onLinkHover(link => {
          highlightNodes.clear();
          highlightLinks.clear();

          if (link) {
            highlightLinks.add(link);
            highlightNodes.add(link.source);
            highlightNodes.add(link.target);
          }
        })
        .autoPauseRedraw(false) // keep redrawing after engine has stopped
        .backgroundColor('#000000')
        .nodeId('id')
        .linkColor(() => 'rgba(0,255,0,0.2)')
        //.linkDirectionalParticles(1)
        .linkWidth(link => highlightLinks.has(link) ? 5 : 1)
        .linkDirectionalParticles(4)
        .linkDirectionalParticleWidth(link => highlightLinks.has(link) ? 4 : 0)
        .onNodeClick(node => window.open(node.url, '_blank'))
        .nodePointerAreaPaint((node, color, ctx) => {
          ctx.fillStyle = color;
          const bckgDimensions = node.__bckgDimensions;
          bckgDimensions && ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);
        })
        //.nodeCanvasObjectMode(node => highlightNodes.has(node) ? 'before' : undefined)
        .nodeCanvasObject((node, ctx, globalScale) => {

          // Calculate radius based on the number of neighbors
          const minRadius = 4; // Minimum radius
          var radius = 4;
          if (typeof node.neighbors !== 'undefined'){
            radius = Math.max(minRadius, minRadius * Math.sqrt(node.neighbors.length));
          }


          // Draw the circle
          ctx.beginPath();
          ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI, false);
          ctx.fillStyle = 'blue';
          ctx.fill();

          const label = node.title;//node.id;
          const fontSize = 12/globalScale;
          ctx.font = `${fontSize}px Sans-Serif`;
          const textWidth = ctx.measureText(label).width;
          const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2); // some padding

          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          // ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);
          //
          // ctx.beginPath();
          // ctx.arc(node.x, node.y, NODE_R * 1.4, 0, 2 * Math.PI, false);
          // ctx.fillStyle = node === hoverNode ? 'red' : 'orange';
          // ctx.fill();
          //
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = node.color;
          ctx.fillText(label, node.x, node.y);

          node.__bckgDimensions = bckgDimensions; // to re-use in nodePointerAreaPaint
        })
        .onNodeHover(node => {
          highlightNodes.clear();
          highlightLinks.clear();
          if (node) {
            highlightNodes.add(node);
            if (typeof node.neighbors !== 'undefined'){
            node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
            node.links.forEach(link => highlightLinks.add(link));
            }
          }
          hoverNode = node || null;
          elem.style.cursor = node ? '-webkit-grab' : null;
        if (settings.enableTooltip) {
        const tooltip = document.getElementById('tooltip');
        if (node) {
          if (node.content){
          if (!node.content.includes('http-equiv="refresh"') && !node.content.includes("window.location.href")){
          tooltip.innerHTML = marked.parse(node.content); // Convert markdown to HTML
          tooltip.style.display = 'block';
          tooltip.style.left = '50px';//`${mousePosition.x}px`; // Use global mouse position
          tooltip.style.top = '50px';//`${mousePosition.y}px`;
          //console.log(mousePosition.x, mousePosition.y,tooltip.innerHTML);
          }
         }
          } else {
          tooltip.style.display = 'none';
        }}
      })
              //.onNodeHover(node => elem.style.cursor = node ? 'pointer' : null)
    });
  }
</script>
